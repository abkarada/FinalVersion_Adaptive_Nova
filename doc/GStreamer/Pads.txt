--Pads & Capabilities--
The pads are the element'S interface to the outside world.

Data streams from one element's source pad to another element's sink pad.

Source --- > Sink

Pads
A pad type is defined bu two properties:its direction and its availability.
A pad can have any of three availabilities:

++Always  --> A pad ALWAYS exists.
++Sometimes --> Exists only in certain cases(and can disappear randomly)
++On Request -->Appear only if EXPLICITLY REQUESTED by applications.

Dynamic Pads::
GstElement *pipeline, *soruce, *demux;
GMainLoop *loop;

gst_init(&argc, &argv);

pipeline = gst_pipeline_new("new_pipe");
source = gst_element_factory_make("filesrc", "source");
g_object_set(source, "location",argv[1], NULL);
demux = gst_element_factory_make("oggdemux", "demuxer");

/* put together a pipeline*/
gst_bin_add_many(GST_BIN(pipeline), source, demux, NULL);
gst_element_link_pads(source,"src", demux, "sink");

  g_signal_connect (demux, "pad-added", G_CALLBACK (cb_new_pad), NULL);

  /* start the pipeline */
  gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_PLAYING);
  /*Now pipeline's all children in the PLAYING state */
  loop = g_main_loop_new (NULL, FALSE);
  g_main_loop_run (loop);

}

It is not uncommon to add elements to the pipeline only from within the 
"pad-added" callback. If you do this, don't forget to set the state of 
the newly-added elements to the target state of the pipeline using
gst_element_set_state () or gst_element_sync_state_with_parent ().

Request Pads::
These pads are not created automatically but are only created on demand.
This is veru useful for multiplexers,aggregators and tee elements.
+Aggregators are elements that merge the content of several input
streams together into one output stream.
+Tee elements are the reverse::Ther are elements that have one input
stream and COPY this stream to each of their output pads,
which are created on request.


Whenever an application needs another copy of the stream, it can
simply request a new output pad from the tee element.

The following piece of code shows how you can request a new output
pad from a “tee” element:

static void
some_function (GstElement * tee)
{
  GstPad *pad;
  gchar *name;

  pad = gst_element_request_pad_simple (tee, "src%d");
  name = gst_pad_get_name (pad);
  g_print ("A new pad %s was created\n", name);
  g_free (name);

  /* here, you would link the pad */

  /* [..] */

  /* and, after doing that, free our reference */
  gst_object_unref (GST_OBJECT (pad));
}

--Tee and Aggregator--

             +--> queue --> sink1
src --> tee -+
             +--> queue --> sink2


src1 --> queue -->+
                  |--> aggregator --> sink
src2 --> queue -->+


The gst_element_request_pad_simple () method can be used to get a
pad from the element based on the name of the pad template. It is
also possible to request a pad that is compatible with another pad
template. This is very useful if you want to link an element to a
multiplexer element and you need to request a pad that is compatible.
The method gst_element_get_compatible_pad () can be used to
request a compatible pad, as shown in the next example. It will
request a compatible pad from an Ogg multiplexer from any input.
Code goes like:

static void 
link_to_multiplexer(GstPad *tolink_pad, GstElement *mux)
{
GstPad *pad;
gchar *srcname, *sinkname;

srcname = gst_pad_get_name(tolink_pad);
pad = gst_element_get_compatible_pad(mux, tolink_pad, NULL);
gst_pad_link(tolink_pad, pad);
gst_object_unref(GST_OBJECT(pad));

  g_print ("A new pad %s was created and linked to %s\n", sinkname, srcname);
  g_free (sinkname);
  g_free (srcname);
}


Pad & Element Connections::
     
           Element
+-----------------------------+
|			      |
|+----------+      +---------+|     
|| Sink Pad |      | Src Pad ||         
|+----------+      +---------+|         
|			      |
+-----------------------------+

--The GstStructure of Pads--

Pad Templates:
  SRC template: 'src'
    Availability: Always
    Capabilities:
      audio/x-raw
                 format: F32LE
                   rate: [ 1, 2147483647 ]
               channels: [ 1, 256 ]

  SINK template: 'sink'
    Availability: Always
    Capabilities:
      audio/x-vorbis


