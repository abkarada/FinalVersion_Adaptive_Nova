--Bus--
A bus is a simple system that takes care of forwarding messages
from the streaming threads to an application in its own thread
context.

Every pipeline contains a bus by default, so applications do not 
need to create a bus or anything.The only thing applications should
do is set a message hadnler on a bus, which is similiar to a signal
handler to an object.
--How to use a bus--

Method One:Run a GLib/Gtk+ main loop(or iterate the default GLib main
context yourself regularly) and attach some kind of a watch to the bus.
Ths way the GLib main loop will check the bus for new messages and notify
you whenever there are messages.

Typically you would use gst_bus_add_watch() or gst_bus_add_signal_watch()
in this case.

Check for messagees on the bus yourself.This can be done using:
gst_bus_peek() and/or gst_bus_poll().

#include <gst/gst.h>

static GMainLoop *loop;

static gboolean 
my_bus_callback(GstBus *bus, GstMessage * message, gpointer data)
{
switch(GST_MESSAGE_TYPE(message)){
    case GST_MESSAGE_ERROR:{
	GError *err;
	gchar *debug;
	
	gst_message_parse_error(message, &err, &debug);
	g_print("Error: %S\n", err->message);
	g_error_free(err);
	g_free(debug);
	g_main_loop_quit(loop);
	break;
	}
    
    case GST_MESSAGE_EOS:
      	/* end-of-stream */
      	g_main_loop_quit (loop);
      	break;
    	default:
      	/* unhandled message */
      	break;
  	}

	return TRUE;


	}

}

gint main(gint argc, gchar **argv){


GstElement *pipeline;
GstBus *bus;
guint bus_watch_id;

gst_init(&argc, &argv);

pipeline = gst_pipeline_new("my_pipeline");

bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));
bus_watch_id = gst_bus_add_watch(bus, my_bus_callback, NULL);
gst_object_unref(bus);


  loop = g_main_loop_new (NULL, FALSE);
  g_main_loop_run (loop);

  /* clean up */
  gst_element_set_state (pipeline, GST_STATE_NULL);
  gst_object_unref (pipeline);
  g_source_remove (bus_watch_id);
  g_main_loop_unref (loop);

  return 0;
  }

